# # 卡牌消除游戏程序设计文档

## 1. 项目概述

### 1.1 项目背景
本项目是基于cocos2d-x 3.17引擎开发的卡牌消除游戏，采用MVC架构模式，实现了卡牌匹配消除、回退操作、动画效果等核心功能。

### 1.2 技术栈
- **游戏引擎**: cocos2d-x 3.17
- **编程语言**: C++11
- **架构模式**: MVC (Model-View-Controller)
- **构建工具**: Visual Studio 2019+
- **平台支持**: Windows Win32

### 1.3 游戏规则
- 玩家可以点击主牌区的卡牌与底牌进行匹配
- 匹配规则：卡牌点数相差为1（如A可以匹配2，Q可以匹配K等）
- 匹配成功后，主牌区卡牌移动到底牌位置，替换原底牌
- 玩家可以从备用牌堆中选择新的底牌
- 支持回退操作，可以撤销最近的操作

## 2. 系统架构

### 2.1 整体架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   View Layer    │    │ Controller Layer │    │   Model Layer   │
│   (UI显示层)     │◄──►│   (控制逻辑层)   │◄──►│   (数据模型层)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         ▲                       ▲                       ▲
         │                       │                       │
    ┌─────────┐            ┌──────────┐           ┌─────────────┐
    │GameView │            │GameCtrl  │           │ GameModel   │
    │CardView │            │UndoMgr   │           │ CardModel   │
    └─────────┘            └──────────┘           └─────────────┘
```

### 2.2 目录结构
```
Classes/
├── models/           # 数据模型层
│   ├── GameModel.h/cpp      # 游戏数据模型
│   ├── CardModel.h/cpp      # 卡牌数据模型  
│   └── UndoModel.h/cpp      # 回退数据模型
├── views/            # 视图表现层
│   ├── GameView.h/cpp       # 游戏主视图
│   └── CardView.h/cpp       # 单张卡牌视图
├── controllers/      # 控制逻辑层
│   └── GameController.h/cpp # 游戏主控制器
├── managers/         # 管理器组件
│   └── UndoManager.h/cpp    # 回退操作管理器
├── services/         # 服务组件
│   └── GameModelFromLevelGenerator.h/cpp # 关卡数据生成器
├── configs/          # 配置相关
│   ├── models/       # 配置数据模型
│   ├── loaders/      # 配置加载器
│   └── resources/    # 资源配置
└── utils/            # 工具类
    └── CardTypes.h   # 卡牌类型定义
```

## 1. 概述

本项目采用MVC（Model-View-Controller）架构设计，实现了一个可扩展的卡牌游戏系统。系统具有清晰的模块划分和职责分离，支持未来功能扩展。

## 2. 架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────┐
│                   View Layer                    │
├─────────────────┬───────────────────────────────┤
│    CardView     │          GameView             │
└─────────────────┴───────────────────────────────┘
                           │
                    ┌─────────────┐
                    │ Controller  │
                    │    Layer    │
                    │             │
                    │GameController│
                    └─────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
  ┌─────────────┐  ┌──────────────┐  ┌─────────────┐
  │  Managers   │  │    Models    │  │  Services   │
  │             │  │              │  │             │
  │UndoManager  │  │  CardModel   │  │GameModelFrom│
  └─────────────┘  │  GameModel   │  │LevelGen...  │
                   │  UndoModel   │  └─────────────┘
                   └──────────────┘
                           │
                   ┌─────────────┐
                   │   Configs   │
                   │             │
                   │LevelConfig  │
                   │CardResConfig│
                   └─────────────┘
```

### 2.2 模块职责

#### 2.2.1 Views层 - 视图层
- **CardView**: 负责单张卡牌的显示和交互
- **GameView**: 管理整个游戏界面的显示和用户交互

#### 2.2.2 Controllers层 - 控制器层  
- **GameController**: 游戏主控制器，协调模型和视图

#### 2.2.3 Models层 - 数据模型层
- **CardModel**: 卡牌数据模型
- **GameModel**: 游戏状态数据模型
- **UndoModel**: 撤销操作数据模型

#### 2.2.4 Managers层 - 管理器层
- **UndoManager**: 撤销功能管理器

#### 2.2.5 Services层 - 服务层
- **GameModelFromLevelGenerator**: 从关卡配置生成游戏模型的服务

#### 2.2.6 Configs层 - 配置层
- **LevelConfig**: 关卡配置数据
- **CardResConfig**: 卡牌资源配置
- **LevelConfigLoader**: 关卡配置加载器

## 3. 核心功能实现

### 3.1 已实现功能

1. **手牌区翻牌替换**
   - 点击手牌堆顶部卡牌，卡牌会移动到底牌位置并替换原底牌

2. **桌面牌和手牌区顶部牌匹配**
   - 点击桌面卡牌，如果点数与底牌相差1，则进行匹配
   - 匹配成功的卡牌会移动到底牌位置并替换

3. **回退功能**
   - 支持撤销之前的操作
   - 卡牌会反向移动到原来的位置
   - 支持多次连续撤销

### 3.2 核心算法

#### 3.2.1 卡牌匹配逻辑
```cpp
bool CardModel::canMatch(const CardModel& other) const
{
    int myValue = getFaceValue();
    int otherValue = other.getFaceValue();
    
    // A可以和K匹配（循环），其他按差1匹配
    if ((myValue == 1 && otherValue == 13) || (myValue == 13 && otherValue == 1))
        return true;
    
    return std::abs(myValue - otherValue) == 1;
}
```

#### 3.2.2 撤销操作管理
```cpp
// 记录操作
_undoManager->recordMoveAction(cardId, fromPos, toPos, previousTrayCard);

// 执行撤销
_undoManager->executeUndo([this]() {
    updateGameView();
    _isProcessingAction = false;
});
```

## 4. 如何添加新卡牌

### 4.1 添加新卡牌类型

1. **扩展CardFaceType枚举**
   ```cpp
   // 在utils/CardTypes.h中添加
   enum CardFaceType
   {
       // ... 现有类型
       CFT_JOKER,          // 新增：小丑牌
       CFT_NUM_CARD_FACE_TYPES
   };
   ```

2. **更新资源配置**
   ```cpp
   // 在CardResConfig.cpp中添加对应的资源路径
   std::string CardResConfig::getNumberImagePath(CardFaceType face, bool isRed, bool isBig)
   {
       // ... 现有逻辑
       case CFT_JOKER: faceStr = "JOKER"; break;
       // ...
   }
   ```

3. **添加对应的图片资源**
   - 在Resources/res/number/目录下添加相应的图片文件
   - 例如：big_red_JOKER.png, big_black_JOKER.png

4. **更新匹配逻辑（如需要）**
   ```cpp
   // 如果新卡牌有特殊匹配规则，在CardModel::canMatch中添加
   bool CardModel::canMatch(const CardModel& other) const
   {
       // 小丑牌可以匹配任意卡牌
       if (_face == CFT_JOKER || other._face == CFT_JOKER)
           return true;
           
       // ... 现有匹配逻辑
   }
   ```

5. **更新关卡配置**
   ```cpp
   // 在LevelConfigLoader中添加新卡牌到测试关卡
   playfieldCards.push_back(LevelConfig::CardConfig(CFT_JOKER, CST_NONE, Vec2(500, 800)));
   ```

### 4.2 完整示例：添加小丑牌

```cpp
// 1. utils/CardTypes.h - 添加枚举
enum CardFaceType
{
    CFT_NONE = -1,
    CFT_ACE,
    // ... 其他类型
    CFT_KING,
    CFT_JOKER,              // 新增
    CFT_NUM_CARD_FACE_TYPES
};

// 2. models/CardModel.cpp - 更新点数值函数
int CardModel::getFaceValue() const
{
    switch (_face)
    {
        // ... 现有case
        case CFT_JOKER: return 0;  // 小丑牌特殊值
        default: return 1;
    }
}

// 3. models/CardModel.cpp - 更新匹配逻辑
bool CardModel::canMatch(const CardModel& other) const
{
    // 小丑牌万能匹配
    if (_face == CFT_JOKER || other.getFace() == CFT_JOKER)
        return true;
        
    // ... 现有匹配逻辑
}
```

## 5. 如何添加新类型的回退功能

### 5.1 扩展撤销操作类型

1. **添加新的撤销操作类型**
   ```cpp
   // 在models/UndoModel.h中添加
   enum UndoActionType
   {
       UAT_MOVE_CARD,
       UAT_REPLACE_TRAY,
       UAT_STACK_TO_TRAY,
       UAT_SPECIAL_MOVE,    // 新增：特殊移动操作
       UAT_COMBO_ACTION     // 新增：连击操作
   };
   ```

2. **扩展撤销动作数据结构**
   ```cpp
   struct UndoAction
   {
       UndoActionType actionType;
       int cardId;
       cocos2d::Vec2 fromPosition;
       cocos2d::Vec2 toPosition;
       std::shared_ptr<CardModel> previousTrayCard;
       
       // 新增字段用于特殊操作
       int extraCardId;                    // 额外卡牌ID
       std::vector<int> affectedCards;     // 受影响的卡牌列表
       std::string customData;             // 自定义数据
   };
   ```

### 5.2 实现新撤销功能

1. **在UndoManager中添加记录方法**
   ```cpp
   // managers/UndoManager.h
   void recordSpecialMove(int cardId, int targetCardId, const Vec2& fromPos, const Vec2& toPos);
   void recordComboAction(const std::vector<int>& cardIds, const std::string& comboData);
   ```

2. **在UndoManager中添加撤销逻辑**
   ```cpp
   // managers/UndoManager.cpp
   bool UndoManager::executeUndo(const std::function<void()>& onAnimationComplete)
   {
       // ... 现有逻辑
       
       switch (lastAction->actionType)
       {
           // ... 现有case
           case UAT_SPECIAL_MOVE:
               undoSpecialMove(lastAction, onAnimationComplete);
               break;
           case UAT_COMBO_ACTION:
               undoComboAction(lastAction, onAnimationComplete);
               break;
       }
   }
   
   void UndoManager::undoSpecialMove(std::shared_ptr<UndoAction> action, const std::function<void()>& onComplete)
   {
       // 实现特殊移动的撤销逻辑
       auto card = _gameModel->findCard(action->cardId);
       auto targetCard = _gameModel->findCard(action->extraCardId);
       
       if (card && targetCard)
       {
           // 恢复卡牌位置
           card->setPosition(action->fromPosition);
           targetCard->setPosition(action->toPosition);
           
           // 播放撤销动画
           if (_undoAnimationCallback)
           {
               _undoAnimationCallback(action->cardId, action->fromPosition, [=]() {
                   _undoAnimationCallback(action->extraCardId, action->toPosition, onComplete);
               });
           }
       }
   }
   ```

### 5.3 完整示例：添加卡牌交换撤销功能

```cpp
// 1. 在GameController中添加卡牌交换功能
bool GameController::executeCardSwap(int cardId1, int cardId2)
{
    auto card1 = _gameModel->findCard(cardId1);
    auto card2 = _gameModel->findCard(cardId2);
    
    if (!card1 || !card2) return false;
    
    Vec2 pos1 = card1->getPosition();
    Vec2 pos2 = card2->getPosition();
    
    // 记录撤销操作
    UndoAction action(UAT_SPECIAL_MOVE, cardId1, pos1, pos2);
    action.extraCardId = cardId2;
    _undoModel->addUndoAction(action);
    
    // 交换位置
    card1->setPosition(pos2);
    card2->setPosition(pos1);
    
    return true;
}

// 2. 在UndoManager中实现撤销
void UndoManager::undoCardSwap(std::shared_ptr<UndoAction> action, const std::function<void()>& onComplete)
{
    auto card1 = _gameModel->findCard(action->cardId);
    auto card2 = _gameModel->findCard(action->extraCardId);
    
    if (card1 && card2)
    {
        // 恢复原始位置
        card1->setPosition(action->fromPosition);
        card2->setPosition(action->toPosition);
        
        // 播放同时撤销动画
        if (_undoAnimationCallback)
        {
            _undoAnimationCallback(action->cardId, action->fromPosition, nullptr);
            _undoAnimationCallback(action->extraCardId, action->toPosition, onComplete);
        }
    }
}
```

## 6. 系统扩展指南

### 6.1 添加新游戏模式
1. 创建新的Controller继承GameController
2. 重写游戏逻辑方法
3. 添加对应的配置和数据模型

### 6.2 添加新UI元素
1. 在Views层创建新的视图类
2. 在对应的Controller中管理新视图
3. 通过回调函数处理交互

### 6.3 添加新特效和动画
1. 在View层添加动画方法
2. 在Controller中调用对应的动画
3. 使用cocos2d-x的Action系统

## 7. 维护性保障

### 7.1 代码规范
- 严格遵循单一职责原则
- 各层之间通过接口通信
- 禁止跨层直接访问

### 7.2 测试策略
- 每个Service类提供静态方法，便于单元测试
- Manager类作为Controller成员，便于Mock测试
- Model类支持数据验证和序列化

### 7.3 性能优化
- 使用对象池管理卡牌视图
- 合理使用智能指针管理内存
- 动画完成后及时清理资源

## 8. 总结

本架构设计具有以下优势：
1. **可维护性**: 清晰的模块划分和职责分离
2. **可扩展性**: 易于添加新功能和新类型
3. **可测试性**: 各模块相对独立，便于单元测试
4. **性能**: 合理的内存管理和资源使用

通过本文档的指导，开发者可以轻松地在现有架构基础上添加新功能，确保系统的稳定性和可维护性。
